\section{Класс NP}

Следующий класс, который мы будем изучать допускает несколько
эквивалентных и одинаково полезных определений.

Одно из них использует понятие \emph{недетерминированной} машины Тьюринга.
Вы, возможно, уже знакомы с понятием НМТ или недетерминированного конечного автомата.
Напомним отличие данной модели вычислений от ДМТ.
Все компоненты такие же как у ДМТ, за тем исключением, что:
$\delta:\left(Q \backslash\left\{q_a, q_r\right\}\right) \times \Gamma^k
    \rightrightarrows Q \times \Gamma^k \times\{L, N, R\}^k$ --- всюду определённая многозначная функция.
На вычисление НМТ логично смотреть как на дерево конфигураций, достижимой из начальной.
Машина принимает слово, если существует ветвь вычислений приводящая её в принимающую конфигурацию.
Машина отвергает слово, если любая ветвь вычислений приводит её в отвергающую конфигурацию.

\begin{definition}[Работа НМТ за $T(n)$]
    Недетерминированная машина $M$ распознает язык $A$ за время $T(n)$, если верно следующее:
    \begin{enumerate}
        \item принимает все слова, лежащие в $A$;
        \item отвергает все слова, не лежащие в $A$;
        \item любое вычисление, начинающееся с $x$ не длиннее $T(|x|)$
              (иначе говоря, машина по любой ветке вычислений
              останавливается не более чем за $T(|x|)$ шагов);
    \end{enumerate}
\end{definition}

Иногда удобнее думать не о многозначной функции переходов,
а о двух функциях $\delta_0$ и $\delta_1$.
От такой вариации время работы изменится в константу раз,
поскольку множество значений многозначной функции $\delta$ имеет константный
(т.е. зависящий не от длины входа, а только от параметров машины) размер,
поэтому выбор нужного значения можно смоделировать
как константное число последовательных бинарных выборов.

Дадим ряд определений, аналогичным тем, что мы давали для ДМТ.

\begin{definition}[$\Ntime$]
    Пусть есть некоторая функция $T:\ \Nat \ra \Nat$.
    Язык $L$ лежит в классе $\Ntime(T(n))$
    существует НМТ, которая распознает его за $O(T(n))$.
\end{definition}

\begin{theorem}
    Покажите, что если $A \in \Ntime(T(n))$, то $A \in \Dtime(2^{O(T(n))})$.
    В частности, недетерминизм не расширяет класс разрешимых языков $\decide$.
\end{theorem}
\begin{proof}
    Как уже упоминалось, у функции перехода может быть не больше некоторой константы $k$ значений.
    Значит, общее количество конфигураций во всех вычислениях,
    начинающихся с данного входа и имеющих длину не больше $T$,
    не превышает $K^T= 2^O(T)$. За время $2^{O(T(n))}$ можно все эти конфигурации перебрать
    (например, обходя дерево) и проверить, встречается ли среди них принимающая.
    Если встречается, то данный вход лежит в языке, иначе не лежит.
\end{proof}

\begin{theorem}[Теорема о недетерминированной иерархии по времени]
    Пусть $f: \Nat \rightarrow \Nat$
    и $g: \Nat \rightarrow \Nat$
    --- строго монотонные конструируемые по времени функции,
    такие что $$f(n+1)=o(g(n))$$. Тогда $\Ntime(f(n)) \subsetneq \Ntime(g(n))$.
\end{theorem}
\begin{proof}
    Смотри в \cite{arora_barak}.
\end{proof}

\begin{definition}[Класс $\np$]
    $\np =\cup_{c=1}^{\infty} \Ntime(n^c)$
\end{definition}
\begin{note}
    $\np$ --- это сокращение от nondeterministic polynomial.
\end{note}

\begin{note}
    Равенство классов $\poly$ и $\np$ --- открытый вопрос.
\end{note}

Введённый выше класс можно так же определить другим образом.
Часто такое определение называется \emph{сертификатным}.

\begin{definition}[Второе определение $\np$]
    Язык $L$ лежит в классе $\np$ тогда и только тогда, когда
    существуют полиномы $p, q: \Nat \rightarrow \Nat$
    и ДМТ $M$ (называющаяся верификатором $L$),
    такая что для всех $x \in \{0,1\}^*$ выполнено
    $$
        x \in L \LRa \exists u \in \{0,1\}^{p(|x|)} \text{ такое, что } M(x, u)=1;
    $$
    и при этом машина $M$ останавливается на входе $(x, u)$
    не более, чем за $q(|(x, u)|)$ шагов.
    Такое $u$, что $M(x, u) = 1$ мы будем называть сертификатом слова $x$.
\end{definition}

\begin{note}
    Интуитивно, $\np$ --- это задачи, решение которых можно быстро проверить.
\end{note}

\begin{theorem}[Эквивалентность двух определений]
    Два предыдущих определения класса NP эквивалентны.
\end{theorem}
\begin{proof}
    Пусть $L$ распознаётся недетерминированной машиной $M$,
    которая работает $O\left(n^c\right)$ шагов.
    Тогда в качестве сертификата можно взять последовательность
    значений функции перехода, а верификатор будет моделировать работу машины $M$,
    используя данные сертификата для выбора одной из ветвей алгоритма.

    Пусть, напротив, для $L$ верно сертификатное определение.
    Тогда сертификат имеет длину $p(|x|)$.
    Недетерминированная машина будет работать следующим образом:
    сначала она недетерминировано напишет сертификат $s$ длины $p(|x|)$,
    a затем запустит $M(x, s)$.
\end{proof}

\begin{problem}[Ослабление определений]
Всюду под <<можно ли>> подразумевается следующее:
останется ли при такой замене класс языков $\np$ неизменным.
\begin{enumerate}
    \item В определении стоит $y \in \Sigma^{p(|x|)}$.
          Можно ли смягчить требование,
          положив $y \in \Sigma^*, |y| \leq p(|x|)$?
    \item В определении МТ останавливается за $q(|x|+|y|)$ шагов.
          Можно ли убрать из требования $y$, оставив $p(|x|)$ шагов?
    \item Можно ли после предыдущих упрощений
          вообще убрать полиномиальное ограничение на $y$,
          получив такое определение $L \in  \np$:
          если существует ДМТ $M$ и полином $p(n)$,
          такие, что для любых $x, y \in \Sigma^*$
          машина $M$ останавливается на входе $(x, y)$
          не более, чем за $p(|x|)$ шагов и
          $$
              (x \in L) \LRa \exists y \in \Sigma^* \text{ такой, что } M(x, y)=1?
          $$
    \item Можно ли в 3 пункте заменить $p(|x|)$ на $p(|y|)$?
\end{enumerate}
\end{problem}
\begin{solution}
    \begin{enumerate}
        \item Если существует более короткий сертификат $y'$,
              то по нему мы можем построить сертификат полной длины $y$
              просто дописав в начале необходимое количество нулей и единичку,
              после чего пропустить их в начале работы.
        \item Да, так как $q(|x|+|y|) = q(|x|+p(|x|)) = p'(|x|)$.
        \item Да. Очевидно, что все языки,
              которые в $\np$ лежат удовлетворяют данному определению.
              Докажем обратное вложение.
              За $p(|x|)$ шагов машина прочитает не более чем $p(|x|)$ символов слова $y$,
              а значит в качестве полиномиального сертификата можно взять
              только те символы слова $y$, которые успевает прочитать наша МТ.
        \item Нет.
              Возьмем в качестве нашего языка любой разрешимый язык и возьмем соответствующую МТ.
              Вместо сертификата будем подавать $1^n(x)$,
              где $n(x)$ это количество тактов работы такой МТ на слове $x$.
    \end{enumerate}
\end{solution}

Наконец, приведем примеры языков из данного класса и изучим замкнутость данного класса
по различным операциям.

\begin{problem}[Примеры $\np$ языков]
Докажите, что следующие языки лежат в $\np$:
\begin{enumerate}
    \item $\sat = \{\phi \mid
              \varphi \text { --- выполнимая булева формула}\}$;
    \item $\clique =\{(G, k) \mid
              \text{в графе $G$ найдётся полный подграф хотя бы на $k$ вершинах}\}$;
    \item $\col =\{G \mid
              \text{вершины графа $G$ можно правильно раскрасить в 3 цвета}\}$;
    \item $\hamcycle =\{G \mid
              \text {в графе $G$ существует гамильтонов цикл}\}$;
    \item $\factoring =\{(N, a) \mid
              \text {у числа $N$ существует делитель меньше $a$}\}$;
    \item $\graphiso = \{(G, Q) \mid
              \text{граф $G$ изоморфен графу $Q$}\}$.
\end{enumerate}
\end{problem}
\begin{solution}
    Приведем решение для первого пункта. Будем строить верификатор для данного языка.
    Верификатор получает на вход формулу $\phi$ и сертификат $y$, после чего проверяет:
    является ли данный сертификат оценкой переменных формулы $\phi$ (для этого его длина
    должна совпасть с количеством переменных в формуле) и является ли данная оценка выполняющей.
    Если обе проверки пройдены, то верификатор принимает такую пару, иначе отвергает.
    Если формула выполнима, то подходящий сертификат найдется --- это её выполняющий набор,
    и наоборот, если нашелся подходящий сертификат, то формула выполнима. Заметим,
    что такой верификатор работает полиномиально по длине формулы.

    Для остальных пунктов верификатор строится аналогично из <<очевидного сертификата>>:
    номера вершин входящих в полный подграф, раскраска графа,
    номера вершин задающих гамильтонов цикл, соответствующий делитель, изоморфизм графов.

\end{solution}

\begin{theorem}[Замкнутость $\np$]
    Класс $\np$ замкнут относительно:
    \begin{enumerate}
        \item объединения;
        \item пересечения;
        \item конкатенации;
        \item итерации.
    \end{enumerate}
\end{theorem}
\begin{proof}
    Везде легче пользоваться сертификатным определением.
    Приведем сертификаты принадлежности к языку, получающемуся после каждой операции:
    \begin{enumerate}
        \item номер языка (как аргумента объединения), в котором слово лежит,
              и сертификат для принадлежности данного слова этому языку;
        \item пара сертификатов принадлежности слова для каждого из языков;
        \item разбиение слова на префикс и суффикс и пара сертификатов;
        \item разбиение слова на части и сертификат принадлежности каждой части языку.
    \end{enumerate}
    Нетрудно убедиться, что все построеные верификаторы работают полиномиально.
\end{proof}

\begin{definition}[$\EXP, \NEXP$]
    $\EXP = \bigcup_{k=0}^{\infty} \Dtime \left(2^{n^k}\right)$,
    $\NEXP = \bigcup_{k=0}^{\infty} \Ntime \left(2^{n^k}\right)$
\end{definition}

\begin{problem}
$\poly = \np \Ra \EXP = \NEXP$
\end{problem}
\begin{solution}
    Предположим $L \in \text{NTIME}\left(2^{n^c}\right)$
    и разрешается НМТ $M$. Докажем, что язык
    $$
        L_{\mathrm{pad}} = \left\{\left\langle x, 1^{2^{|x|^c}}\right\rangle: x \in L\right\}
    $$
    лежит в NP.

    Предъявим НМТ для $L_{\mathrm{pad}}$: по входу $y$,
    сначала проверим, что существует $z$,
    такое что $y=\left\langle z, 1^{\left.2^{|z|}\right|^c}\right\rangle$.
    Если нет, то отвергнем слово, иначе запустим $M$ на $z$
    в течении $2^{|z|^c}$ шагов и выведем ответ.
    Очевидно, что время работы полиномиально по $|y|$,
    а значит $L_{\mathrm{pad}} \in \text{NP}$.

    Однако, если $\text{P}=\text{NP}$, то $L_{\mathrm{pad}}$ лежит в $\poly$.
    Но тогда $L$ лежит в $\EXP$: что бы проверить входит ли $x$ в $L$,
    нам нужно просто дописать необходимое количество единиц и
    проверить результат не вхождение в $L_{\mathrm{pad}}$
    используя полиномиальную ДМТ для $L_{\mathrm{pad}}$.
\end{solution}
\begin{note}
    Прием, который мы использовали только что, называется padding.
\end{note}

\begin{problem}
Докажите, что $\poly = \np$ тогда и только тогда,
когда $\poly$ замкнут относительно нестирающих морфизмов.
\end{problem}
\begin{solution}
    Пусть $\poly = \np$. Тогда рассмотрим образ $M$ языка $L$ под нестирающим морфизмом $\phi$.
    $M$ принадлежит $\np$ по следующей причине: сертификатом слова $\phi(x)$ является слово $x$,
    верификатор вычисляет морфизм от сертификата, проверяет совпадение результата со входом
    и проверяет принадлежность сертификата к $L$

    В обратную сторону. Пусть язык $L$ лежит в $\np$. Рассмотрим тогда язык таких пар:
    слово из $L$ и сертификат его принадлежности. Будем считать, что слово записывается в
    алфавите $\{0, 1\}$, а сертификат в алфавите $\{0', 1'\}$. Такой язык, по очевидной причине,
    лежит в $\poly$. Тогда подействуем на него морфизмом $\phi(0')=\phi(1')=1'$. Так как
    $\poly$ замкнут относительно нестирающих морфизмов, то получившийся язык $L'$ лежит в $\poly$.
    Но тогда принадлежность $L$ к $\poly$ доказывается так: достаточно дописать к слову
    $p(|x|)$ символов $1'$ (где $p$ --- полином ограничивающий длину сертификата) и проверить
    принадлежность получившегося к $L'$.
\end{solution}


