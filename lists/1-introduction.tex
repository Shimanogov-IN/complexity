\section{Предисловие}

Напомним некоторые определения и факты,
которые известны из курса вычислимости.

Базовой моделей вычислений для нас будет являться \emph{$k$-ленточная ДМТ}.
Будем считать, что слушатели знакомы с понятием конфигурации МТ и
способами формализовать ей работу.
Определим время распознавания языка машиной,
измеряя его <<в худшем случае>>.

\begin{definition}[Работа за время $T(n)$]
Машина распознаёт язык $A$ за время $T(n)$, если она 
\begin{itemize}
    \item принимает все слова, лежащие в $A$;
    \item отвергает все слова, не лежащие в $A$;
    \item на каждом слове $x$ работает не больше $T(|x|)$ шагов.
\end{itemize}
\end{definition}

Далее нам будет удобно считать, что все объекты, с которыми мы работаем
представляются в бинарной кодировке,
так что входной алфавит всех МТ равен $\{0, 1\}$.
От кодировки $\phi$ и обратного отображения $\psi$
мы хотим следующего:
\begin{enumerate}
    \item $\phi$ определено для всех объектов;
    \item $\phi$ инъективно;
    \item $\psi$ определено для всех строк;
    \item $\psi(\phi(w)) = w$;
    \item $\phi$ и $\psi$ вычисляются \emph{эффективно}.
\end{enumerate}
Для того, что бы было выполнено третье свойство будем считать,
что для всех $w$, таких что прообраз $w$ относительно $\phi$ пуст,
$\psi(w)$ равно некоторому конкретному, фиксированному объекту
(одинаковому для всех таких $w$).

Зачастую на вход алгоритму мы будем подавать несколько объектов.
Пусть они уже представлены бинарными строками. Покажем, что
конечный упорядоченный набор бинарных строк $w_i$ можно закодировать
одной бинарной строкой. Действительно,
давайте сначала запишем слово $w_1\#w_2\#\ldots \# w_n$,
а затем подействуем на него морфизмом $f$ заданным
$f(0) = 00, f(1) = 11, f(\#) = 01$.

Натуральные числа достаточно просто записать в бинарной системе счисления,
целые представить как пару, где первый элемент отвечает за знак числа
(например $0$ для отрицательного и $1$ для положительного), а второй ---
его абсолютная величина.
Аналогично, рациональные числа можно представлять как пару
из натурального и целого.

Вектора можно задавать как упорядоченный набор
соответствующих элементов, а матрицу --- как набор векторов.
Графы можно задавать матрицей смежности. Еще мы часто будем говорить про
булевы формулы. Зададим морфизм
$g\left( \neg \right) = 000,
g\left( \vee \right) = 010,
g\left( \wedge \right) = 011,
g\left( \text{левая скобка} \right) = 100,
g\left( \text{правая скобка} \right) = 101,
g\left( x_i \right) = 111f(\#i_2\#)$.
Здесь $f$ --- морфизм определенный выше,
а $i_2$ --- это двоичная запись числа $i$.
Нетрудно видеть, что по такой кодировке легко восстановить исходную формулу.

Особый интерес для нас представляет возможность закодировать
в алфавите $\{0, 1\}$ любую машину Тьюринга и наоборот,
восстанавливать по строке МТ.
От подобной кодировки нам хотелось бы потребовать дополнительное свойство,
которое будет удобно в дальнейшем:
для каждой МТ существует бесконечное количество строк,
которые ей соответствуют.
Например, можно считать что кодировка построенная по МТ
обязана начинаться с 0,
а все кодировки отличающиеся наличием единиц в начале кодируют ту же МТ.


Мы не будем строить конкретный способ кодирования машин Тьюринга
(какой-нибудь скорее всего вам известен с курса вычислимости),
но будем предполагать, что на протяжении всего курса мы пользуемся одним,
заранее выбранным каноническим способом построения описаний:
его не тяжело построить,
используя приемы использованные для кодирования других объектов.

\begin{problem}
Предложите кодировку $\phi$ пары бинарных строк $\langle x, y \rangle$,
такую, что длина $\phi\left( \langle x, y \rangle \right)$ равна
$|x|+|y|+ \log|x|+ 2 \log \log|x|+O(1)$.
\end{problem}
\begin{solution}
Сначала построим кодировку с длиной $|x|+|y|+ 2 \log|x| + O(1)$.
Идея следующая: если мы знаем длину $x$, то по слову $xy$ можно
восстановить $x$ и $y$. Для того, что бы понять, где в слове
заканчивается указание на длину $x$, запишем её как $f(|x|_2\#)$.
Получаем, что $f(|x|\#)xy$ -- искомая кодировка.

Что бы получить кодировку искомой длины достаточно проделать
этот трюк два раза: а именно построить слово $f(||x||_2\#)|x|xy$.
\end{solution}

Из курса вычислимости вам должно быть известно о существовании
универсальной машины Тьюринга. Уточним так же время работы такой
машины.

\begin{theorem}[Универсальная машина Тьюринга]
Существует МТ $U$, такая что 
$\forall x,\ \alpha \in \{0, 1\}^*:\ U(x, \alpha) = M_\alpha(x)$, где $M_\alpha$
обозначает машину Тьюринга с кодом $\alpha$.

Более того, если $M_\alpha$ останавливается на входе $x$ за $T$ шагов, тогда $U(x, \alpha)$ остановится за $CT\log T$ шагов, где $C$ зависит только от размера алфавита, количества лент и состояний машины $M_\alpha$.
\end{theorem}
\begin{proof}
Cмотри в \cite{arora_barak}.
\end{proof}

Так же напомним тезис Чёрча-Тьюринга. Отдельно отметим,
что это не математическое утверждение,
а неформальный тезис, который описывает наше <<понимание реальности>>.
Однако его можно подтвердить для отдельно взятой <<модели вычислений>>.

\begin{definition}[Сильный тезис Тьюринга]
Любое вычисление на реальном устройстве можно смоделировать на
одноленточной машине Тьюринга с полиномиальным замедлением.
\end{definition}