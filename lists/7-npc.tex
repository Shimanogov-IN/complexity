\section{Сводимости и $\np$-полнота}

\begin{definition}[Сводимость по Карпу]
Пусть $A$ и $B$ --- два языка.
Тогда $A$ сводится по Карпу к $B$,
если существует всюду определённая функция $f:\{0,1\}^* \ra \{0,1\}^*$,
вычислимая за полиномиальное время, такая что $x \in A \LRa f(x) \in B$.
Обозначение: $A \leq_p B$.
\end{definition}

\begin{theorem}[Cвойства сводимости]
Сводимость по Карпу:
\begin{enumerate}
    \item рефлексивна
    \item транзитивна
\end{enumerate}
\end{theorem}
\begin{proof}
\begin{enumerate}
    \item Достаточно рассмотреть тождественную функцию.
    \item Для транзитивности нужно рассмотреть композицию:
    если $f$ сводит $A$ к $B$,
    а $g$ сводит $B$ к $C$, то $g \circ f$ сводит $A$ к $C$: 
    $x \in A \LRa f(x) \in B \LRa g(f(x)) \in C$.
    При этом если и $f$, и $g$ вычисляются за полиномиальное время,
    то $g \circ f$ также вычисляется за полиномиальное время.
\end{enumerate}
\end{proof}
\begin{note}
Стоит заметить, что если существует какая-то полиномиальная функция
осуществляющая сводимость, то обратная к ней может вовсе не существовать
(если исходная функция была не инъективной) или быть не полиномиальной.
\end{note}

\begin{definition}[Сложность языка в классе]
Язык $L$ является трудным в некотором классе $T$
относительно сводимости $\propto$,
если для любого $A \in T$ выполнено $A \propto L$.
\end{definition}

\begin{definition}[Полнота языка в классе]
Язык $L$ является полным в некотором классе $T$
относительно сводимости $\propto$ ,
если он труден в $T$ относительно сводимости $propto$ и $L \in T$.
\end{definition}
\begin{note}
Далее мы пока будем рассматривать лишь сводимость по Карпу,
иногда называя её \emph{полиномиальной сводимостью}.
\end{note}

\begin{problem}[Полнота в классе $\poly$]
Найдите все языки которые:
\begin{enumerate}
    \item трудные в $\poly$
    \item полные в $\poly$
\end{enumerate}
\end{problem}
\begin{solution}
\begin{enumerate}
    \item В $\poly$ трудны все нетривиальные языки.
    Рассмотрим сводимость $A \leq_p B$ для $A$ из $\poly$:
    если $B \neq \emptyset$ и $B \neq \{0,1\}^*$,
    то можно зафиксировать $b_1 \in B$ и $b_2 \notin B$
    и рассмотреть функцию
    $$f(x)= \left\{\begin{array}{ll}b_1, & x \in A \\ 
    b_2, & x \notin A\end{array}\right..$$ 
    Она, очевидно, удовлетворяет всем необходимым свойствам.
    \item Из определения и предыдущего пункта, очевидно,
    что в $\poly$ полны все нетривиальные языки из $\poly$.
\end{enumerate}
\end{solution}

\begin{theorem}[Свойства сводимости]
Верно следующее:
\begin{enumerate}
    \item Если $B \in \poly,\ A \leq_p B$, то $A \in \poly$.
    \item Если $B \in \np,\ A \leq_p B$, то $A \in \np$.
\end{enumerate}
\end{theorem}
\begin{proof}
\begin{enumerate}
    \item Достаточно заметить, что характеристическая функция $\chi_A$
    представляется как композиция $\chi_B \circ f$.
    Если $B \in P$, то $\chi_B$ вычисляется за полиномиальное время,
    а если $A \leqslant_p B$, то соответствующая $f$ также
    вычисляется за полиномиальное время.
    Значит, их композиция, т.е. $\chi_A$, тоже
    вычисляется за полиномиальное время, что и означает $A \in \poly$.
    \item Если $W(y, s)$ будет верификатором принадлежности $y$ к $B$,
    то $V(x, s)=W(f(x), s)$ будет верификатором принадлежности $x$ к $A$:
    если $x \in A$, то для $f(x)$ будет существовать сертификат и $V$ его примет,
    а если $x \notin A$, то для $f(x)$ сертификата существовать не будет.
\end{enumerate}
\end{proof}

\begin{definition}[$\npc, \conpc$]
$\np$-полными ($\npc$) языками называются языки полные в $\np$
относительно сводимости по Карпу.

$\conp$-полными ($\conpc$) языками называются языки полные в $\conp$
относительно сводимости по Карпу.
\end{definition}

\begin{note}
Отсюда следует, что если хоть одна задача из $\npc$ лежит в $\poly$, то $\poly = \np$.
\end{note}

\begin{problem}
\begin{enumerate}
    \item Верно ли, что $L \in \npc \iff \overline L \in \conpc$?
    \item Верно ли, что если $L \in \npc$ и $L \in \conp$, то $\np=\conp$?
    \item Верно ли, что если $L \in \np$ и $L \in \conpc$, то $\np=\conp$?
\end{enumerate}
\end{problem}
\begin{solution}
\begin{enumerate}
    \item Да, рассмотрим произвольный $\np$ язык $A$.
    По определению сводимости $f(A) \subset L$ и
    $f(\overline A) \subset \overline{L}$,
    а значит произвольный $coNP$ язык сводится к $\overline{L}$.
    \item Да, рассмотрим произвольный NP язык $A$.
    Так как $L$ в coNP, то $\overline{L} \leq_p L$.
    Но $\overline{L}$ в coNPC, значит $\overline{A} \leq_p \overline{L}$.
    А значит любой coNP язык сводится к NP языку,
    а значит любой coNP язык сам NP.
    Но по условию и любой NP язык сводится к coNP языку,
    а значит сам coNP. Значит классы совпадают.
    \item Аналогично предыдущей.
\end{enumerate}
\end{solution}

\begin{note}
Напомним, что:
\begin{itemize}
    \item Пропозициональная формула называется выполнимой,
    если она истинна хотя бы на каком-то наборе значений переменных.
    Языком $\sat$ называется множество выполнимых пропозициональных формул.
    \item Пропозициональная формула записана в $3$-КНФ,
    если она представлена в конъюнктивной нормальной форме,
    в которой любой дизъюнкт включает ровно три литерала.
    Языком $\tsat$ называется множество выполнимых $3$-КНФ.
\end{itemize}
\end{note}
\begin{theorem}[Теорема Кука-Левина]
$\sat \in \npc$
\end{theorem}
\begin{proof}
Приведем небольшой набросок доказательства.

Будем сводить произвольный $\np$-язык к $\sat$, сводящая функция
по произвольной функции будет строить формулу.

Идея состоит в записи булевой формулы,
которая моделирует работу верификатора на данном слове.
При этом выполнимость формулы будет равносильно наличию сертификата для данного слова.
Нужно построить формулу, гарантирующую корректность протокола работы верификатора.
Она будет конъюнкцией трёх формул, гарантирующих корректность начала,
окончания и каждого шага.

Для этого нужно построить формулу, проверяющую корректность каждого шага.
Ключевой идеей здесь является то, что вычисления на машине Тьюринга локальны,
т.е. на каждом шаге изменяется небольшая часть ленты,
и это изменение зависит от небольшой части ленты на предыдущем шаге.
Более точно, значение символа в каждой ячейке зависит
от значений символов в $4$ ячейках на предыдущем шаге:
(зависимость от самой правой ячейки появляется, когда машина сдвигается налево).

Вид этой зависимости полностью определяется программой машиной Тьюринга,
а значит, может быть описан некоторой фиксированной пропозициональной
формулой. Эту формулу нужно скопировать для каждого из возможных кусков ленты
и взять конъюнкцию всех формул.

Таким образом, можно построить формулу, размер которой есть полином от
исходных данных. Её выполнимость будет равносильна тому,
что для некоторого сертификата $s$ машина на входе $x$
остановится в принимающем состоянии, т.е. $x \in L$.
Таким образом, произвольный язык $L$ сведётся к $\sat$.

Полное доказательство смотри в \cite{musatych}.
\end{proof}

\begin{problem}[Сводимость $\sat$ к $\tsat$]
Покажите, что $\tsat \in \npc$.
\end{problem}
\begin{solution}
Сведем $\tsat$ к $\sat$.
Пусть $\varphi$ - пропозициональная формула.
Введём переменную для каждой её подформулы (включая исходные переменные и всю формулу).
Каждая подформула, составленная из двух,
задаёт утверждение вида $q=r \wedge s$ (для произвольной пропозициональной связки).

Его можно представить как $3$-КНФ
(в данном случае $
(q \vee \neg r \vee \neg s) \wedge
(\neg q \vee r \vee \neg s) \wedge
(\neg q \vee \neg r \vee s) \wedge
(\neg q \vee r \vee s)$). 
Взяв конъюнкцию всех таких формул,
мы получим $3$-КНФ,
выполнимость которой эквивалентна выполнимости исходной формулы.
Действительно, выполняющий набор исходной формулы задаст значения всех подформул,
которые будут выполняющим набором полученной формулы.
И наоборот, из выполняющего набора новой формулы можно выделить выполняющий набор исходной.

Осталось пояснить, почему этот алгоритм работает полиномиальное время.
Ясно, что достаточно построить за полиномиальное время дерево синтаксического разбора формулы,
дальнейшие операции занимают константное время для каждой его вершины.
Построение дерева также несложно:
путём подсчёта скобочного итога можно выделить из формулы две подформулы,
из которых она получена, и повторить процедуру с ними рекурсивно.
Это займёт линейное время для каждой подформулы, т.е. всего квадратичное время.
% TODO review
\end{solution}
\subsection{Примеры сходимостей и NPC задач}
\begin{note}
Вспомним следующие языки:
\begin{itemize}
    \item $\clique =\{(G, k) \mid$ в графе $G$ есть клика из $k$ вершин$\}$;
    \item $\indset =\{(G, k) \mid$ в графе $G$ есть независимое множество из $k$ вершин$\}$;
    \item $\vcover =\{(G, k) \mid$ в графе $G$ есть вершинное покрытие из $k$ вершин$\}$.
\end{itemize}
\end{note}
\begin{note}
Что бы доказать, что какая-то задача лежит в NPC надо свести к ней задачу,
про которую известно, что она NPC (например SAT),
а не наоборот.
Еще надо не забыть показать, что она тоже лежит в NP
(это можно сделать и с помощью обратной сводимости). 
\end{note}
\begin{problem}
Покажите, что $\indset \in \npc$.
\end{problem}
\begin{solution}
Докажем, что $3SAT \leq_p INDSET$.
Построим граф следующим образом:
каждому вхождению литерала сопоставим вершину графа.
Вершины, соответствующие литералам из одного дизъюнкта, соединим рёбрами.
Также соединим все противоположные литералы, например $p$ и $\neg p$.
На этом построение графа заканчивается, размер независимого множества возьмём равным $k$.
Если у формулы есть выполняющий набор,
то в каждом дизъюнкте есть хотя бы один истинный литерал.
Соответствующие вершины образуют независимое множество,
поскольку эти литералы из разных дизъюнктов,
а литералы вида $p$ и $\neg p$ не могут быть истинны одновременно.
Этих вершин как раз $k$.

Если, наоборот, есть независимое множество из $k$ вершин
то эти вершины обязаны соответствовать различным дизъюнктам.
А поскольку среди этих вершин нет одновременно литералов вида $p$ и $\neg p$,
то можно взять такие значения переменных, при которых все задействованные литералы истинны.
Эти значения и будут выполняющим набором.
\end{solution}
\begin{problem}
Постройте все сводимости между $\clique$, $\indset$ и $\vcover$.
\end{problem}
\begin{solution}
Доказательство. Задачи $\clique$ и $\indset$ полиномиально сводятся
друг к другу переходом к дополнению графа, т.е. графу $\bar{G}$,
в котором те и только те рёбра, которых нет в $G$.
Задачи $\indset$ и $\vcover$ сводятся друг к другу заменой $k$ на $n-k$,
где $n$ - число вершин.
Дело в том, что дополнение к любому вершинному покрытию есть независимое множество:
если вершинное покрытие задело все рёбра, то между оставшимися вершинами рёбер быть не может,
иначе эти рёбра не были бы задеты. И наоборот, если между оставшимися рёбер нет,
то все рёбра покрыты взятыми.
\end{solution}
\begin{note}
Напомним, что 
\begin{itemize}
    \item $\hampath$ это язык описаний графов, в которых есть гамильтонов путь.
    \item $\hamcycle$ это язык описаний графов, в которых есть гамильтонов цикл.
\end{itemize}
\end{note}
\begin{problem}
Постройте сводимость $\hampath$ к $\hamcycle$ и наоборот.
\end{problem}
\begin{solution}
\begin{itemize}
    \item Для начала сведем $\hamcycle$ к $\hampath$.
    Выберем одну вершину $A$ в нашем графе и добавим вершину $A'$
    связанную только с ней. Далее добавим вершину $B$,
    связанную только с теми же вершинами,
    что и $A$ и вершину $B'$ связанную только с $B$.
    Если в исходном графе существовал цикл,
    то в получившемся графе существует путь
    $A' \ra A \ra \ldots \ra B \ra B'$.
    Наоборот, если в получившемся графе есть путь,
    то он обязан иметь вид $A'\ra A\ra \ldots \ra B \ra B'$,
    а значит в исходном графе будет цикл $A\ra \ldots \ra A$,
    так как если из предпоследнего элемента пути был переход в $B$, то будет и в $A$.
    \item Теперь сведем $\hampath$ к $\hamcycle$.
    Добавим к графу вершину $V$, связанную со всеми остальными.
    Если в исходном графе существовал путь $A \ra \ldots \ra B$,
    то в получившемся существует цикл $V \ra A \ra \ldots \ra B \ra V$.
    Наоборот, если в получившемся графе существует цикл,
    то удалив из него вершину $V$ получим путь в исходном графе.
\end{itemize}
\end{solution}
\begin{note}
Можно так же показать (предположим, что это было сделано на лекции),
что $\sat$ сводится к $\hampath$, а значит оба этих языка тоже лежат в $\npc$.
\end{note}
\begin{problem}[Полуклика]
Докажите, что язык графов содержащих клику на половине своих вершин 
$\mathrm{HALFCLIQUE}$ лежит в $\npc$. 
\end{problem}
\begin{solution}
Эта задача очевидно лежит в $\np$,
давайте докажем ее $\np$ трудность сведя к ней язык $\clique$.
Обозначим количество вершин в графе за $m$,
а желаемый размер клики за $k$. Введем параметр $t=2k-m$.
Наша сводимость разбивается на два случая:
\begin{itemize}
    \item $k\geq\frac{m}{2}\ (t\geq0)$.
    Добавим к исходному графу $|t|$ независимых вершин,
    тем самым получим граф размера $2k$.
    Очевидно, что новые вершины не могут участвовать в кликах,
    так что наличие в новом графе половинной клики (размера $k$)
    равносильно наличию клики такого же размера в исходном графе.
    \item $k<\frac{m}{2}\ (t<0)$. Добавим к исходному графу $|t|$ 
    вершин связанных со всеми вершинами графа, получим граф размера $2m-2k$.
    Если в исходном графе была размера $k$, 
    то мы можем добавить туда все новые вершины и
    получить в новом графе клику размера $m-2k+k=m-k=\frac{(2m-2k)}{2}$.
    Если же в исходном графе клики такого размера не было,
    то и в новом графе максимальный размер клики
    не будет достигать половины количества вершин.
\end{itemize}
\end{solution}