\section{Сертификат Пратта}

\begin{definition}[$\primes$]
    $\primes$ --- это язык всех простых чисел (в двоичной записи).
\end{definition}

\begin{problem}
Язык $\primes$ --- это $\conp$ язык.
\end{problem}
\begin{solution}
    % TODO
\end{solution}

Далее нашей целью будет доказать, что $\primes \in \poly$.

\begin{theorem}[О первообразном корне]
    Число $p>2$ является простым тогда и только тогда,
    когда существует число $r$ такое, что $1<r<p$ и выполняется
    \begin{enumerate}
        \item $r^{p-1}=1\ (\bmod\ p)$;
        \item $r^x \neq 1\ (\bmod\ p)$ для каждого $x=1,2, \ldots, p-2$.
    \end{enumerate}
    Такой $r$ называется первообразным корнем простого числа $p$.
\end{theorem}
\begin{proof}
    Смотри в \cite{primes}.
\end{proof}

\begin{theorem}[О необходимых проверках]
    Пункт 2 в предыдущей теореме не нужно проверять для каждого $x$,
    достаточно проверить его столько раз, сколько различных простых делителей имеет число $p-1$.
\end{theorem}
\begin{proof}
    Пусть $a$ такое число, что
    \begin{enumerate}
        \item $a^{p-1}=1\ (\bmod\ p)$;
        \item $a^x \neq 1\ (\bmod\ p)$ для каждого $x$,
              имеющего вид $\frac{p-1}{q}$,
              где $q$ --- некоторый простой делитель $p-1$.
    \end{enumerate}

    Пусть $y$ --- наименьшее положительное число такое,
    что $a^y=1\ (\bmod\ p)$ (хотя бы одно такое существует, это $p - 1$ по предположению).
    Найдём тогда два числа $c$ и $d$ такие,
    что $c y+d=p-1$ и $0 \leq d<y$ ($c$ равно целочисленному частному, а $d$ - остатку от деления).
    Тогда
    $$
        \begin{gathered}
            a^{c y+d}=a^{p-1}=1 \quad(\bmod\ p) \\
            a^{c y}=\left(a^y\right)^c=1^c=1 \quad(\bmod\ p)
        \end{gathered}
    $$
    Это означает, что $a^d=1\ (\bmod\ p)$,
    в силу минимальности положительного $y$ получаем,
    что $d=0$ и тогда $y$ является делителем числа $p-1$.
    Поскольку $a^{\frac{p-1}{q}} \neq 1\ (\bmod\ p)$,
    число $y$ не делит никакую дробь вида $\frac{p-1}{q}$ для простого делителя $q$.
    При этом $y$ делит $p-1$ - значит $y=p-1$.
\end{proof}

\begin{problem}
Рассмотрим следующее доказательство того, что $\primes$ --- это $\np$ язык.
Сертификат числа $n$ тогда имеет вид
\begin{enumerate}
    \item первообразный корень $a$ для $n$;
    \item разложение $n-1$ на простые сомножители $\left(q_1, \ldots, q_t\right)$
          с учётом кратностей $\left(s_1, \ldots, s_t\right)$.
\end{enumerate}
Пусть мы проверяем на простоту число $n$,
длина входа тогда есть $\log n$.
Каждый простой делитель числа $n-1$ не превосходит $\frac{n-1}{2}$,
а всего у $n$ не более $\log n$ простых делителей
(с учётом кратности - иначе их произведение больше $n$ ).
Итого, длина списка простых делителей (с учётом кратностей) не превосходит $\log ^2 n$.

Алгоритм проверки возьмёт $n$ и сертификат и
\begin{enumerate}
    \item проверит корректность --- что числа в сертификате натуральные,
          лежат в нужном диапазоне и что $n-1$ есть произведение $\Pi q_i^{s_i}$;
    \item проверит, что $a^{n-1}=1\ (\bmod\ n)$;
    \item для каждого $q_i$ проверит, что $a^{\frac{n-1}{q_i}} \neq 1\ (\bmod\ n)$.
\end{enumerate}
При вычислениях алгоритм использует быстрое возведение в степень:
для вычисления $a^x$ требуется сделать не более $2 \log x$ операций умножения над числами.
Поскольку все вычисления делаются по модулю $n$,
длина чисел на любом промежуточном этапе не превышает $\log n$.
Каждое умножение над числами такой длины делается за $O\left(\log ^2 n\right)$ (можно и быстрее).
Итого, алгоритм проверки совершает $O\left(\log ^3 n\right)$ (битовых) операций.

Найдите ошибку в этом доказательстве.
\end{problem}
\begin{solution}
    Проверим, что 91 - простое число.
    Сертификат простоты будет $(10 ;(2,45) ;(1,1))$.
    Алгоритм проверяет следующее:
    \begin{enumerate}
        \item Все числа корректны и $2 \cdot 45=90=91-1$.
        \item $10^{90}=1\ (\bmod\ 91)$. Для этого мы вычисляем последовательно (всё по модулю 91)
              $$
                  \begin{gathered}
                      10^2=9,10^4=81,10^8=9,10^{16}=81,10^{32}=9,10^{64}=81, \\
                      10^{64+16}=10^{80}=9,10^{80+8}=10^{88}=81,10^{88+2}=10^{90}=1
                  \end{gathered}
              $$

        \item $10^{\frac{90}{2}} \neq 1\ (\bmod\ 91)$. Ранее полученные вычисления дают
              $$
                  10^{32+8}=10^{40}=81,10^{40+4}=10^{44}=9,10^{45}=81 \neq 1
              $$
              $10^{\frac{90}{45}} \neq 1\ (\bmod\ 91)$.
              Тривиально из предыдущего $10^2=9 \neq 1\ (\bmod\ 91)$.
    \end{enumerate}
    Окончательно алгоритм заключает, что 91 - простое число.

    Проблема тут в том, что $91=7 \cdot 13$.
\end{solution}

\begin{theorem}[$\primes \in \np$]
    Язык $\primes$ --- это $\np$ язык.
\end{theorem}
\begin{proof}
    Сертификат $c_n$ для простоты числа $n>2$ имеет вид
    \begin{enumerate}
        \item первообразный корень $a$ для $n$,
        \item разложение $n-1$ на простые сомножители $\left(q_1, \ldots, q_t\right)$
              с учётом кратностей $\left(s_1, \ldots, s_t\right)$,
        \item набор $\left(c_{q_1}, \ldots, c_{q_t}\right)$, где $c_{q_i}$
              --- сертификат простоты для $q_i$.
    \end{enumerate}
    Алгоритм проверки возьмёт $n$ и сертификат, а затем
    \begin{enumerate}
        \item проверит корректность входа --- что все числа в сертификате натуральные
              и лежат в нужном диапазоне, синтаксис корректен и т.д.,
        \item проверит, что $n-1$ есть произведение $\Pi q_i^{s_i}$,
        \item проверит, что каждое число $q_i$ простое с помощью сертификата $c_{q_i}$,
        \item проверит, что $a^{n-1}=1(\bmod n)$,
        \item для каждого $q_i$ проверит, что $a^{\frac{n-1}{q_i}} \neq 1\ (\bmod\ n)$.
    \end{enumerate}
    Алгоритм получается рекурсивным и его корректность опирается на то,
    что у числа $n - 1$ существует разложение на простые множители.
    Это верно для всех чисел, больших двух.
    Число 2 не подходит под вышестоящую схему,
    так что сертификатом его простоты является оно само,
    грубо говоря, алгоритм "знает", что 2 простое.

    Докажем по индукции,
    что сертификат содержит $4 \log_2 n-4$ значений помимо двоек.
    Это легко проверить для $3$,
    теперь возьмем $p>3$ и рассмотрим его потомков $p_1, \ldots, p_k$.
    По предположению индукции сертификат $p_i$ содержит не больше $4 \log _2 p_i-4$ значений,
    так что всего получается
    $$
        1+\sum_{i=1}^k\left(4 \log _2 p_i-4\right)=
        -4 k+4 \log _2 p_1 \cdots p_k \leq 4 \log _2 p-4,
    $$
    так как $k \geq 2$ и $p_1 \ldots p_k=p-1$.

    Каждое $p_i$ занимает не более чем $\log n$ бит,
    так что весь сертификат имеет размер $\mathrm{O}\left((\log n)^2\right)$ бит.

    Так как значений помимо 2 всего $\mathrm{O}(\log n)$ и
    каждое требует мы можем проверить на корректность за $\mathrm{O}(\log^3 n)$,
    то алгоритм работает за $\mathrm{O}(\log^4 n)$.
\end{proof}
\begin{example}
    Сертификат для 1783 имеет вид
    $$
        \left(10 ;(2,3,11) ;(1,4,1) ;\left(c_2, c_3, c_{11}\right)\right)
    $$
    где
    $$
        \begin{gathered}
            c_2=2, \\
            c_3=\left(2 ; 2 ; 1 ; c_2\right), \\
            c_{11}=\left(2 ;(2,5) ;(1,1) ;\left(c_2, c_5\right)\right), \\
            c_5=\left(2 ; 2 ; 2 ; c_2\right) .
        \end{gathered}
    $$
\end{example}

\begin{note}
    Мы получили, что $\primes \in \conp \cap \np$.
    Однако в 2002 году был предложен полиномиальный тест Агравала--Каяла--Саксены на простоту,
    и оказалось что $PRIMES \in P$,
    однако рассмотрение данного вопроса лежит за пределами нашего курса.
    Желающие могут посмотреть оригинальную статью \cite{primes_p}.
\end{note}